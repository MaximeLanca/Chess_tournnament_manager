import copyimport csvimport osfrom Tournament_manager.controllers.players_controller import PlayersControllerfrom Tournament_manager.models.player import Playerfrom Tournament_manager.models.tournament import Tournamentfrom Tournament_manager.models.round import Roundfrom Tournament_manager.models.match import Matchfrom Tournament_manager.views.interface import Interfaceclass TournamentController:    def __init__(self):        self.tournament = None        self.round_ = None        self.match = None        self.matches_id_list = []        self.players_controller = None        self.players_list = []        self.loaded_history_matches = []        self.loaded_current_match = []    def run(self):        """Star the program for prepare tournament. """        Interface.introduction()        tournament_description = Interface.ask_tournament_description()        tournament_name = Interface.ask_tournament_name()        tournament_location = Interface.ask_tournament_location()        tournament_start_date = str(Interface.ask_tournament_start_date())        tournament_end_date = str(Interface.ask_tournament_end_date())        number_of_round = Interface.ask_round()        self.players_controller = PlayersController(Interface.ask_number_of_players())        self.players_controller.get_players_information()        self.players_list = self.players_controller.players_list        players_ids = []        for player in self.players_list:            players_ids = [player.chess_national_id]        self.tournament = Tournament(tournament_name,                                     tournament_location,                                     tournament_start_date,                                     tournament_end_date,                                     number_of_round,                                     players_ids,                                     tournament_description                                     )        current_match = False        Interface.send_message_for_started_tournament(self.tournament.tournament_name)        self.start_tournament(current_match)    def speed_run(self):        Interface.second_introduction()        tournament_name = "Quick tournament2"        tournament_location = "Barcelone"        number_of_round = 3        number_of_players = 4        tournament_start_date = "00-00-0000"        tournament_end_date = "00-00-0001"        tournament_description = "Welcome to the tournament"        self.players_controller = PlayersController(number_of_players)        self.players_list = self.players_controller.quick_do_players_list()        players_id = []        for player in self.players_list:            players_id.append(player.chess_national_id)        self.tournament = Tournament(tournament_name,                                     tournament_location,                                     tournament_start_date,                                     tournament_end_date,                                     number_of_round,                                     players_id,                                     tournament_description                                     )        Interface.send_message_for_started_tournament(self.tournament.tournament_name)        self.start_tournament(current_match=False)    def start_tournament(self, current_match: bool):        """Star tournament with the new matches or loaded matches according to argument 'current_match'.        :param current_match: Determine if a match has been loaded.        """        if current_match:            round_number = self.round_.round_number        else:            round_number = 1            self.tournament.save_tournament_db()        for nb_round in range(round_number, self.tournament.number_of_round + 1):            if current_match is False:                self.round_ = Round(nb_round)            self.round_.save_round_db()            self.round_.get_round_id_db()            self.tournament.rounds_history.append(self.round_.last_round_id)            self.define_players_for_match(nb_round, current_match)            self.round_.update_round_db()            self.tournament.update_tournament_db()            current_match = False        self.tournament.update_tournament_db()        self.define_tournament_winner()    def define_players_for_match(self, nb_round: int, current_match: bool):        """Define players for matches.            Save history pairs to avoid duplication of matches and save the tournament        :param nb_round : Round number in tournament        :param current_match : determine if a match has been loaded        """        history_pairs = self.tournament.matches_history        Interface.display_round(nb_round)        players_list_copy = copy.deepcopy(self.players_list)        if current_match:            players_list_copy = self.remove_copied_players_of_list(players_list_copy)        while players_list_copy:            copied_player_1 = None            copied_player_2 = None            if players_list_copy:                copied_player_1 = players_list_copy.pop(0)                for player in players_list_copy:                    if (copied_player_1.chess_national_id, player.chess_national_id) not in history_pairs and (                            player.chess_national_id, copied_player_1.chess_national_id) not in history_pairs:                        copied_player_2 = player                        break                players_chess_national_id_pair = (copied_player_1.chess_national_id, copied_player_2.chess_national_id)            else:                players_list_copy = copy.deepcopy(self.players_list)                players_chess_national_id_pair = self.loaded_current_match[0]                for player in players_list_copy:                    if player.chess_national_id == self.loaded_current_match[0][0]:                        index = players_list_copy.index(player)                        copied_player_1 = players_list_copy.pop(index)                    if player.chess_national_id == self.loaded_current_match[0][1]:                        index = players_list_copy.index(player)                        copied_player_2 = players_list_copy[index]            self.tournament.matches_history.append(players_chess_national_id_pair)            pairs_of_players = self.map_copied_players_with_players_list(copied_player_1, copied_player_2)            players_list_copy.remove(copied_player_2)            if current_match is False:                self.match = Match(pairs_of_players[0], pairs_of_players[1], winner=None)            self.start_match()            self.round_.matches = [self.loaded_history_matches]            self.round_.update_round_db()            current_match = False    def start_match(self):        """ Start match  """        Interface.display_match(self.match)        answer = Interface().ask_match_winner()        self.match.save_match_db()        self.round_.matches_id_list.append(self.match.id_)        self.round_.update_round_db()        self.tournament.update_tournament_db()        if answer == 4:            print("You have stopped the tournament.")            exit()        else:            self.match.define_match_winner(answer)            self.match.update_result_match_db()            self.match.player_1.update_players_score_db()            self.match.player_2.update_players_score_db()    def remove_copied_players_of_list(self, players_list_copy) -> list:        """Remove copied players who played in loaded tournament. This allows the tournament ti pick up            where it left off.        :param players_list_copy :  copied player list from player list original        """        removed_players_list = []        for player in players_list_copy:            for match in self.tournament.matches_history:                if player.chess_national_id == match[0]:                    removed_players_list.append(player)                if player.chess_national_id == match[1]:                    removed_players_list.append(player)        for player in removed_players_list:            players_list_copy.remove(player)        return players_list_copy    def map_copied_players_with_players_list(self, copied_player_1: object, copied_player_2: object) -> tuple:        """map players between original list and copied list with chess national ID data        :param:            copied_player_1: Copied player 1            copied_player_2: Copied player 2        :return:            List of original players ( Object)        """        player_1 = None        player_2 = None        while player_1 is None and player_2 is None:            for player in self.players_list:                if player.chess_national_id == copied_player_1.chess_national_id:                    player_1 = player                elif player.chess_national_id == copied_player_2.chess_national_id:                    player_2 = player                    break                else:                    continue        return [player_1, player_2]    def define_tournament_winner(self):        """Define the winner with the highest score """        self.players_list.sort(key=lambda x: x.score, reverse=True)        print(f"The tournament winner is: {self.players_list[0]} with "              f"{self.players_list[0].score} points")        Interface.players_ranking(self.tournament.tournament_name, self.players_list)    def load_tournament(self):        """Load a tournament in db with all datas players"""        requested_tournament = Interface.ask_tournament_for_to_load()        self.check_loaded_tournament_name(requested_tournament)        self.tournament = Tournament.from_db(requested_tournament)        players_controller = PlayersController()        self.players_list = players_controller.get_players_data_db(self.tournament.players_id)        rounds_list = []        for id_round in self.tournament.rounds_history:            rd_ = Round.from_db(id_round)            rounds_list.append(rd_)            for match_id in rd_.matches_id_list:                loaded_match = Match.from_db(match_id)                players_pair = (loaded_match.player_1, loaded_match.player_2)                if loaded_match.winner is None:                    self.loaded_current_match.append(players_pair)                else:                    self.tournament.matches_history.append(players_pair)        self.round_ = rounds_list[-1]        self.prepare_round_for_load_tournament()        current_match = True        Interface.send_message_for_started_tournament(self.tournament.tournament_name)        self.start_tournament(current_match)    def prepare_round_for_load_tournament(self):        """Prepare round for loading tournament """        matches_list = []        for match in self.loaded_current_match[0]:            matches_list.append(match)        players_current_match = []        for player in self.players_list:            if player.chess_national_id in matches_list:                players_current_match.append(player)        self.match = Match(players_current_match[0], players_current_match[1], None)        self.round_.matches = self.match    def check_loaded_tournament_name(self, tournament_name: str):        """Check if a tournament has been played        :param tournament_name: tournament name        """        searched_tournament = Tournament.search_tournament_db(tournament_name)        while True:            if searched_tournament is False:                answer = Interface.send_error_message_on_tournament(tournament_name)                if answer == "t":                    self.load_tournament()                elif answer == "e":                    exit()                else:                    print("Not valid answer ")            else:                break    def handle_request_for_report(self, answer):        if answer == 1:            fieldnames = ['Name', 'Birthday', 'Chess national ID']            report_name = "players_list_report.csv"            self.create_report_folder()            self.create_players_list_report(fieldnames, report_name)        if answer == 2:            fieldnames = ['Tournament name',                          'Tournament location',                          'Start date',                          'End date',                          'Number of round',                          'Number of players']            report_name = "tournaments_list_report.csv"            self.create_report_folder()            self.create_all_tournament_report(fieldnames, report_name)        if answer == 3:            fieldnames = ['Location', 'Start date', 'End date']            report_name = "tournament_information.csv"            self.create_report_folder()            self.create_date_and_location_tournament_report(fieldnames, report_name)        if answer == 4:            fieldnames = ['Name', 'Birthday', 'Chess national ID']            report_name = "tournament_players.csv"            self.create_report_folder()            self.create_tournament_players_list_report(fieldnames, report_name)        if answer == 5:            fieldnames = ['Round', 'Player 1', 'Player 2', 'Winner']            report_name = "tournament_round_and_matches.csv"            self.create_report_folder()            self.create_tournament_round_and_matches_report(fieldnames, report_name)    @staticmethod    def create_report_folder():        """ Folders and csv file creation """        try:            os.mkdir('../output')        except FileExistsError:            Interface.send_message_on_existing_folder_report()    @staticmethod    def create_players_list_report(fieldnames, report_name):        """ Create type report        :param fieldnames        :param report_name        """        with (open(f'../output/{report_name}', 'w', newline='', encoding='utf-8') as csvfile):            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)            writer.writeheader()            saved_players_db = Player.search_all_players_db()            sorted_players_db = sorted(saved_players_db, key=lambda x: x['Name'])            for info in sorted_players_db:                writer.writerow({'Name': info['Name'],                                 'Birthday': info['Birthday'],                                 'Chess national ID': info['Chess_national_ID'],                                 })        Interface.send_message_after_extraction_of_db()    @staticmethod    def create_all_tournament_report(fieldnames, report_name):        """ Create type report        :param fieldnames        :param report_name        """        with (open(f'../output/{report_name}', 'w', newline='', encoding='utf-8') as csvfile):            saved_tournaments_db = Tournament.search_all_tournaments_db()            for info in saved_tournaments_db:                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)                writer.writeheader()                writer.writerow({'Tournament name': info['Tournament_name'],                                 'Tournament location': info['Tournament_location'],                                 'Start date': info['Start_date'],                                 'End date': info['End_date'],                                 'Number of round': info['Number_of_round'],                                 'Number of players': len(info['Players_ID'])                                 })        Interface.send_message_after_extraction_of_db()    @staticmethod    def create_date_and_location_tournament_report(fieldnames, report_name):        """ Create type report        :param fieldnames        :param report_name        """        with (open(f'../output/{report_name}', 'w', newline='', encoding='utf-8') as csvfile):            tournament_name = Interface.ask_tournament_name()            found_tournament = Tournament.search_tournament_db(tournament_name)[0]            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)            writer.writeheader()            writer.writerow({'Location': found_tournament['Tournament_location'],                             'Start date': found_tournament['Start_date'],                             'End date': found_tournament['End_date']                             })        Interface.send_message_after_extraction_of_db()    @staticmethod    def create_tournament_players_list_report(fieldnames, report_name):        """ Create type report        :param fieldnames        :param report_name        """        with (open(f'../output/{report_name}', 'w', newline='', encoding='utf-8') as csvfile):            tournament_players = []            tournament_name = Interface.ask_tournament_name()            found_tournament = Tournament.search_tournament_db(tournament_name)[0]            players_id_list = found_tournament["Players_ID"]            for id_ in players_id_list:                player = Player.search_player_db(id_)[0]                tournament_players.append(player)            sorted_players_list = sorted(tournament_players, key=lambda x: x['Name'])            for info in sorted_players_list:                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)                writer.writeheader()                writer.writerow({'number of player': info['Number_of_player'],                                 'Name': info['Name'],                                 'Birthday': info['Birthday'],                                 'Chess national ID': info['Chess_national_ID'],                                 'Score': info['Score'],                                 })        Interface.send_message_after_extraction_of_db()    @staticmethod    def create_tournament_round_and_matches_report(fieldnames, report_name):        """ Create type report        :param fieldnames        :param report_name        """        with (open(f'../output/{report_name}', 'w', newline='', encoding='utf-8') as csvfile):            tournament_name = Interface.ask_tournament_name()            found_tournament = Tournament.search_tournament_db(tournament_name)[0]            round_history_id_list = found_tournament['Round_history']            for round_id in round_history_id_list:                rd = Round.from_db(round_id)                round_number = rd.round_number                matches_history_list = rd.matches_id_list                for match_id in matches_history_list:                    match = Match.from_db(match_id)                    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)                    writer.writeheader()                    writer.writerow({'Round': round_number,                                     'Player 1': match.player_1,                                     'Player 2': match.player_2,                                     'Winner': match.winner,                                     })        Interface.send_message_after_extraction_of_db()